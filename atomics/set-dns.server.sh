#!/usr/bin/env bash

# ==============================================================================
# Script Atomique: set-dns.server.sh 
# Description: Configurer les serveurs DNS système
# Author: Generated with AI assistance
# Version: 1.0
# Date: 2025-10-04
# ==============================================================================

set -euo pipefail

SCRIPT_NAME="set-dns.server.sh"
SCRIPT_VERSION="1.0"
DEBUG=${DEBUG:-0}
VERBOSE=${VERBOSE:-0}
QUIET=${QUIET:-0}
JSON_ONLY=${JSON_ONLY:-0}
DNS_SERVERS=()
BACKUP=${BACKUP:-1}
FORCE=${FORCE:-0}

show_help() {
    cat << EOF
Usage: $SCRIPT_NAME [OPTIONS] <dns_server1> [dns_server2] [dns_server3]

Description:
    Configure les serveurs DNS système en modifiant /etc/resolv.conf
    avec sauvegarde et validation des serveurs.

Arguments:
    <dns_server>     Adresse IP du serveur DNS (jusqu'à 3 serveurs)

Options:
    -h, --help       Afficher cette aide
    -v, --verbose    Mode verbeux
    -d, --debug      Mode debug
    -q, --quiet      Mode silencieux
    -j, --json-only  Sortie JSON uniquement
    -f, --force      Forcer même si serveurs non accessibles
    --no-backup      Ne pas créer de sauvegarde
    
Exemples:
    $SCRIPT_NAME 8.8.8.8 8.8.4.4
    $SCRIPT_NAME 1.1.1.1 1.0.0.1 8.8.8.8
    $SCRIPT_NAME --no-backup 208.67.222.222
EOF
}

parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help) show_help; exit 0 ;;
            -v|--verbose) VERBOSE=1; shift ;;
            -d|--debug) DEBUG=1; VERBOSE=1; shift ;;
            -q|--quiet) QUIET=1; shift ;;
            -j|--json-only) JSON_ONLY=1; QUIET=1; shift ;;
            -f|--force) FORCE=1; shift ;;
            --no-backup) BACKUP=0; shift ;;
            -*) echo "Option inconnue: $1" >&2; exit 2 ;;
            *) DNS_SERVERS+=("$1"); shift ;;
        esac
    done

    [[ ${#DNS_SERVERS[@]} -eq 0 ]] && { echo "Au moins un serveur DNS requis" >&2; exit 2; }
    [[ ${#DNS_SERVERS[@]} -gt 3 ]] && { echo "Maximum 3 serveurs DNS" >&2; exit 2; }
}

validate_ip() {
    local ip="$1"
    local IFS='.'
    read -ra octets <<< "$ip"
    
    [[ ${#octets[@]} -eq 4 ]] || return 1
    
    for octet in "${octets[@]}"; do
        [[ "$octet" =~ ^[0-9]+$ ]] || return 1
        [[ $octet -ge 0 && $octet -le 255 ]] || return 1
    done
    return 0
}

test_dns_server() {
    local server="$1"
    local test_domain="google.com"
    
    # Test avec nslookup si disponible
    if command -v nslookup >/dev/null 2>&1; then
        timeout 5 nslookup "$test_domain" "$server" >/dev/null 2>&1 && return 0
    fi
    
    # Test avec dig si disponible
    if command -v dig >/dev/null 2>&1; then
        timeout 5 dig @"$server" "$test_domain" >/dev/null 2>&1 && return 0
    fi
    
    # Test basique de connectivité
    if command -v nc >/dev/null 2>&1; then
        timeout 3 nc -u -z "$server" 53 2>/dev/null && return 0
    fi
    
    return 1
}

get_current_dns_servers() {
    local current_servers=()
    
    if [[ -f /etc/resolv.conf ]]; then
        while IFS= read -r line; do
            if [[ "$line" =~ ^nameserver[[:space:]]+([0-9.]+) ]]; then
                current_servers+=("${BASH_REMATCH[1]}")
            fi
        done < /etc/resolv.conf
    fi
    
    printf '%s\n' "${current_servers[@]}"
}

backup_resolv_conf() {
    local backup_file="/etc/resolv.conf.backup.$(date +%Y%m%d_%H%M%S)"
    
    if [[ -f /etc/resolv.conf ]]; then
        cp /etc/resolv.conf "$backup_file" && echo "$backup_file"
    fi
}

create_resolv_conf() {
    local dns_servers=("$@")
    local temp_file
    temp_file=$(mktemp)
    
    # En-tête
    cat > "$temp_file" << EOF
# Generated by $SCRIPT_NAME on $(date)
# Original backed up if --backup option used

EOF
    
    # Ajouter les serveurs DNS
    for server in "${dns_servers[@]}"; do
        echo "nameserver $server" >> "$temp_file"
    done
    
    # Ajouter options communes
    cat >> "$temp_file" << EOF

# Common options
options timeout:2 attempts:3 rotate single-request-reopen
EOF
    
    echo "$temp_file"
}

check_systemd_resolved() {
    systemctl is-active systemd-resolved >/dev/null 2>&1
}

detect_network_manager() {
    systemctl is-active NetworkManager >/dev/null 2>&1 || pgrep -f NetworkManager >/dev/null 2>&1
}

main() {
    parse_args "$@"
    
    local errors=() warnings=()
    
    # Vérifier les permissions
    if [[ ! -w /etc/ ]]; then
        errors+=("No write permission to /etc directory")
    fi
    
    # Valider les adresses IP
    for server in "${DNS_SERVERS[@]}"; do
        if ! validate_ip "$server"; then
            errors+=("Invalid IP address: $server")
        fi
    done
    
    # Détecter les conflits potentiels
    if check_systemd_resolved; then
        warnings+=("systemd-resolved is active - changes may be overridden")
    fi
    
    if detect_network_manager; then
        warnings+=("NetworkManager detected - may override DNS settings")
    fi
    
    # Tester les serveurs DNS si pas de force
    if [[ $FORCE -eq 0 ]] && [[ ${#errors[@]} -eq 0 ]]; then
        for server in "${DNS_SERVERS[@]}"; do
            if ! test_dns_server "$server"; then
                warnings+=("DNS server $server not responding - use --force to proceed anyway")
                errors+=("DNS server validation failed for $server")
            fi
        done
    fi
    
    if [[ ${#errors[@]} -eq 0 ]]; then
        local start_time end_time duration backup_file=""
        local current_servers=()
        
        start_time=$(date +%s)
        readarray -t current_servers < <(get_current_dns_servers)
        
        # Créer une sauvegarde
        if [[ $BACKUP -eq 1 ]]; then
            backup_file=$(backup_resolv_conf)
            if [[ -z "$backup_file" ]]; then
                warnings+=("Failed to create backup of resolv.conf")
            fi
        fi
        
        # Créer le nouveau resolv.conf
        local temp_resolv_conf
        temp_resolv_conf=$(create_resolv_conf "${DNS_SERVERS[@]}")
        
        # Appliquer les changements
        if cp "$temp_resolv_conf" /etc/resolv.conf 2>/dev/null; then
            rm -f "$temp_resolv_conf"
            
            # Vérifier les changements
            local new_servers=()
            readarray -t new_servers < <(get_current_dns_servers)
            
            end_time=$(date +%s)
            duration=$((end_time - start_time))
            
            # Tester les nouveaux serveurs
            local working_servers=0
            for server in "${new_servers[@]}"; do
                if test_dns_server "$server"; then
                    working_servers=$((working_servers + 1))
                fi
            done
            
            cat << EOF
{
  "status": "success",
  "code": 0,
  "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
  "script": "$SCRIPT_NAME",
  "message": "DNS servers configured successfully",
  "data": {
    "requested_servers": [$(printf '"%s",' "${DNS_SERVERS[@]}" | sed 's/,$//')],
    "previous_servers": [$(printf '"%s",' "${current_servers[@]}" | sed 's/,$//')],
    "current_servers": [$(printf '"%s",' "${new_servers[@]}" | sed 's/,$//')],
    "working_servers": $working_servers,
    "total_servers": ${#new_servers[@]},
    "backup_created": $([ -n "$backup_file" ] && echo "true" || echo "false"),
    "backup_file": "$backup_file",
    "duration_seconds": $duration,
    "systemd_resolved_active": $(check_systemd_resolved && echo "true" || echo "false"),
    "network_manager_active": $(detect_network_manager && echo "true" || echo "false")
  },
  "errors": [],
  "warnings": [$(printf '"%s",' "${warnings[@]}" | sed 's/,$//')"]
}
EOF
        else
            rm -f "$temp_resolv_conf"
            errors+=("Failed to update /etc/resolv.conf")
        fi
    fi
    
    if [[ ${#errors[@]} -gt 0 ]]; then
        cat << EOF
{
  "status": "error",
  "code": 1,
  "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
  "script": "$SCRIPT_NAME",
  "message": "DNS server configuration failed",
  "data": {},
  "errors": [$(printf '"%s",' "${errors[@]}" | sed 's/,$//')],
  "warnings": [$(printf '"%s",' "${warnings[@]}" | sed 's/,$//')"]
}
EOF
        exit 1
    fi
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi